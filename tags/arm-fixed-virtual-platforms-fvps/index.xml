<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ARM Fixed Virtual Platforms (FVPs) on zlaazlaa's blog</title><link>https://blog.zlaaa.top/tags/arm-fixed-virtual-platforms-fvps/</link><description>Recent content in ARM Fixed Virtual Platforms (FVPs) on zlaazlaa's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 06 Jan 2025 21:01:07 +0800</lastBuildDate><atom:link href="https://blog.zlaaa.top/tags/arm-fixed-virtual-platforms-fvps/index.xml" rel="self" type="application/rss+xml"/><item><title>ARM Fixed Virtual Platforms (FVPs)中运行 Hypervisor，Guest OS 的全局变量没有置零</title><link>https://blog.zlaaa.top/p/global-val-is-not-zero-in-fvp/</link><pubDate>Mon, 06 Jan 2025 21:01:07 +0800</pubDate><guid>https://blog.zlaaa.top/p/global-val-is-not-zero-in-fvp/</guid><description>&lt;h2 id="前言">前言
&lt;/h2>&lt;p>最近在为 Hypervisor 适配新平台 ARM Fixed Virtual Platforms (FVPs)，具体架构是 FVP + Hypervisor + Guest OS，发现 Guest OS 无法启动。然而，QEMU + Hypervisor + Guest OS 一切正常。进一步调试后发现，在 FVP 场景下，Guest OS 中所有未初始化的全局变量均不是零值，导致默认它们为零的代码出现错误。&lt;/p>
&lt;p>根据 C 标准，未初始化的全局变量应默认置零：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>如果一个具有自动存储周期的对象不被显式地初始化，那么其值是不确定的。如果具有静态或线程存储周期的一个对象不被显式初始化，那么&lt;/strong>&lt;/p>
&lt;p>—— 如果它具有指针类型，那么它被初始化为一个空指针；&lt;/p>
&lt;p>—— 如果它具有算术类型，那么它被初始化为（正的或负的）零；&lt;/p>
&lt;p>—— 如果它是一个聚合类型，那么每个成员被初始化（递归地），根据以上规则，并且任何填充被初始化为零比特；&lt;/p>
&lt;p>—— 如果它是一个联合体，那么第一个命名成员被（递归地）初始化，根据以上规则，并且填充被初始化为零比特。&lt;/p>
&lt;/blockquote>
&lt;h2 id="问题分析">问题分析
&lt;/h2>&lt;p>对于 ELF 文件来说，存储变量的叫数据段。数据段分为 .data 段和 .bss 段，其中 .data 段存储&lt;strong>已经初始化&lt;/strong>的全局变量和静态变量，.bss 段存储&lt;strong>未经初始化&lt;/strong>的全局变量。&lt;/p>
&lt;p>.bss 段属于 nload 段，在镜像中不占空间，镜像被加载后，才会映射到内存，此时 .bss 段的内容继承自被映射的内存区域。&lt;/p>
&lt;p>很不幸，我运行的 Guest OS 并没有清零自己的 .bss 段，而且 Hypervisor 的实现也比较简单，仅仅是做了以下内存映射：GPA -&amp;gt; HVA -&amp;gt; HPA，将自身的 memory 区域一一映射给 Guest OS，也没有对这部分内存做置零处理。&lt;/p>
&lt;p>但是为什么 QEMU + Hypervisor + Guest OS 正常运行，而 FVP + Hypervisor + Guest OS 不行呢？&lt;/p>
&lt;p>这是因为 QEMU 提供的可用内存的默认值都是 0：
&lt;img src="https://blog.zlaaa.top/post/global-val-is-not-zero-in-fvp/imgs/qemu-memory-in-gdb.png"
loading="lazy"
alt="qemu-memory-in-gdb"
>
而 FVP 提供的可用内存区域默认值是 0xcfdfdfdf 与 0xdfdfdfcf 的循环：
&lt;img src="https://blog.zlaaa.top/post/global-val-is-not-zero-in-fvp/imgs/fvp-memory-in-gdb.png"
loading="lazy"
alt="fvp-memory-in-gdb"
>&lt;/p>
&lt;hr>
&lt;p>具体见 FVP 的 params：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">FVP_Base_RevC-2xAEMvA --list-params &lt;span class="p">|&lt;/span> grep fill
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dmc.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dmc.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dmc_phy.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dmc_phy.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dummy_local_dap_rom.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dummy_local_dap_rom.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dummy_ram.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dummy_ram.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dummy_usb.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.dummy_usb.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.ns_dram.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.ns_dram.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.psram.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.psram.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.rl_dram.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.rl_dram.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.rt_dram.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.rt_dram.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.s_dram.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.s_dram.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.secureDRAM.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.secureDRAM.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.secureSRAM.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.secureSRAM.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.sram.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.sram.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.vram.fill1&lt;span class="o">=&lt;/span>&lt;span class="m">3755990991&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xdfdfdfcf&amp;#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bp.vram.fill2&lt;span class="o">=&lt;/span>&lt;span class="m">3487555551&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xcfdfdfdf&amp;#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster0.ext_abort_fill_data&lt;span class="o">=&lt;/span>&lt;span class="m">18302063723721653757&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xfdfdfdfcfcfdfdfd&amp;#39; : Returned data, if external aborts are asynchronous&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster0.randomize_unknowns_at_reset&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="c1"># (bool , init-time) default = &amp;#39;0&amp;#39; : Will fill in unknown bits in registers at reset with random value using register_reset_data as seed, it overrides scramble_unknowns_at_reset&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster0.register_reset_data&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0x0&amp;#39; : Data used to fill register bits when they become UNKNOWN at reset.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster0.register_reset_data_hi&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0x0&amp;#39; : Data used to fill the upper-half of 128-bit registers when the bits become UNKNOWN at reset.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster0.scramble_unknowns_at_reset&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="c1"># (bool , init-time) default = &amp;#39;1&amp;#39; : Will fill in unknown bits in registers at reset with register_reset_data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster0.unpred_extdbg_unknown_bits&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0x0&amp;#39; : Data used to fill only in UNKNOWN bit-fields of external debug registers e.g., EDPFR and EDDFR.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster1.ext_abort_fill_data&lt;span class="o">=&lt;/span>&lt;span class="m">18302063723721653757&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0xfdfdfdfcfcfdfdfd&amp;#39; : Returned data, if external aborts are asynchronous&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster1.randomize_unknowns_at_reset&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="c1"># (bool , init-time) default = &amp;#39;0&amp;#39; : Will fill in unknown bits in registers at reset with random value using register_reset_data as seed, it overrides scramble_unknowns_at_reset&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster1.register_reset_data&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0x0&amp;#39; : Data used to fill register bits when they become UNKNOWN at reset.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster1.register_reset_data_hi&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0x0&amp;#39; : Data used to fill the upper-half of 128-bit registers when the bits become UNKNOWN at reset.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster1.scramble_unknowns_at_reset&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="c1"># (bool , init-time) default = &amp;#39;1&amp;#39; : Will fill in unknown bits in registers at reset with register_reset_data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cluster1.unpred_extdbg_unknown_bits&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="c1"># (int , init-time) default = &amp;#39;0x0&amp;#39; : Data used to fill only in UNKNOWN bit-fields of external debug registers e.g., EDPFR and EDDFR.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上配置项显示了 FVP 可以对如下内存区域进行配置：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;code>bp.dmc.*&lt;/code> 和 &lt;code>bp.dmc_phy.*&lt;/code>&lt;/strong>&lt;br>
表示 DRAM Controller（内存控制器）及其物理层相关的内存填充值。&lt;br>
用途：初始化内存控制器的地址空间，可能包括配置寄存器、缓冲区等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>bp.ns_dram.*&lt;/code>&lt;/strong>&lt;br>
表示 Non-Secure DRAM（非安全动态随机存取存储器）的填充值。&lt;br>
用途：初始化普通内存区域（非安全内存），模拟器启动时填充的默认模式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>bp.rl_dram.*&lt;/code> 和 &lt;code>bp.rt_dram.*&lt;/code>&lt;/strong>&lt;br>
表示 Real-time Left 和 Real-time Right DRAM，分别对应系统的左右两部分实时内存。&lt;br>
用途：通常用于模拟分区的实时内存。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>bp.s_dram.*&lt;/code> 和 &lt;code>bp.secureDRAM.*&lt;/code>&lt;/strong>&lt;br>
表示 Secure DRAM（安全动态随机存取存储器）的填充值。&lt;br>
用途：存储安全相关数据，例如密钥、加密缓存等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>bp.psram.*&lt;/code>&lt;/strong>&lt;br>
表示 PSRAM（伪静态随机存取存储器）的填充值。&lt;br>
用途：嵌入式设备中用于提高性能的混合型存储器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>bp.sram.*&lt;/code> 和 &lt;code>bp.secureSRAM.*&lt;/code>&lt;/strong>&lt;br>
表示 SRAM（静态随机存取存储器）和 Secure SRAM 的填充值。&lt;br>
用途：SRAM 通常用于高速缓存或快速存储，Secure SRAM 用于安全用途。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>bp.vram.*&lt;/code>&lt;/strong>&lt;br>
表示 VRAM（视频随机存取存储器）的填充值。&lt;br>
用途：用于存储图形数据或显示缓冲区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>bp.dummy_*&lt;/code>&lt;/strong>&lt;br>
表示模拟器中用于占位或辅助调试的虚拟内存区域（如 dummy_ram、dummy_usb）。&lt;br>
用途：不对应真实硬件，而是提供测试或开发的功能。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>关于 fill1 和 fill2，如果他们的值分别是 A 和 B，那么 FVP 的对应内存区间的值就会是 ABABABABABABABABABAB&amp;hellip;&amp;hellip; 的循环。&lt;/p>
&lt;p>如果不对 FVP 内存初始值进行配置，.bss 段“展开”后的内容就是默认的 0xcfdfdfdfdfdfdfcf，这也是为什么 debug 过程中看到所有未经初始化的值都是 0xcfdfdfdfdfdfdfcf。&lt;/p>
&lt;p>对于我这个例子，Guest OS 镜像是嵌入 Hypervisor 镜像中的，经过测试，发现 Hypervisor 镜像所在内存区间为 bp.s_dram，为 FVP 添加如下启动参数后，Guest OS 可以正常启动：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl"> -C bp.s_dram.fill1&lt;span class="o">=&lt;/span>0x0 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -C bp.s_dram.fill2&lt;span class="o">=&lt;/span>0x0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>PS:&lt;/p>
&lt;p>关于为什么是 bp.s_dram，&lt;a class="link" href="https://documentation-service.arm.com/static/5f4d1264ca7b6a3399375cb4" target="_blank" rel="noopener"
>FVP 手册&lt;/a>中可以找到一些蛛丝马迹。&lt;del>其实我是挨个试的&lt;/del>&lt;/p>
&lt;p>Hypervisor 镜像所在内存区间的安全属性是 &lt;code>P&lt;/code>
&lt;img src="https://blog.zlaaa.top/post/global-val-is-not-zero-in-fvp/imgs/fvp-memory-map.png"
loading="lazy"
>&lt;/p>
&lt;p>对于&lt;code>P&lt;/code>，默认的处理策略是安全访问和非安全访问全部拒绝，我猜测拒绝非安全访问的区间，都在 bp.s_dram 的配置范围内。但是我也查看了一些&lt;code>N/S&lt;/code>区间，并不是所有的&lt;code>N/S&lt;/code>区间都在 bs.s_dram 的配置范围内。如果有知道的同学可以在评论区⬇️讨论下。
&lt;img src="https://blog.zlaaa.top/post/global-val-is-not-zero-in-fvp/imgs/fvp-secure-memory.png"
loading="lazy"
>&lt;/p></description></item><item><title>使用 lite-cornea 调试 ARM Fixed Virtual Platforms (FVPs)</title><link>https://blog.zlaaa.top/p/debug-fvp-via-gdb/</link><pubDate>Sun, 05 Jan 2025 15:59:16 +0800</pubDate><guid>https://blog.zlaaa.top/p/debug-fvp-via-gdb/</guid><description>&lt;h2 id="概述">概述
&lt;/h2>&lt;p>在调试 ARM FVP 模型时，直接通过 GDB 连接是行不通的。虽然 ARM 官方为付费版 Fast Model 提供了 &lt;a class="link" href="https://developer.arm.com/documentation/100964/1115/Plug-ins-for-Fast-Models/GDBRemoteConnection" target="_blank" rel="noopener"
>GDB 插件&lt;/a>，但免费版 Base Model 并不支持该功能。取而代之，Base Model 提供了一种名为 Iris Debug Server 的 Python Debug API。因此，要使用 GDB 调试 Base FVP，需要通过中间工具进行协议转译。&lt;/p>
&lt;p>本文将介绍如何使用 lite-cornea 工具简化 FVP 的调试过程。&lt;/p>
&lt;h2 id="调试工具选择">调试工具选择
&lt;/h2>&lt;p>目前找到的 Iris-to-GDB 转译工具有以下两个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a class="link" href="https://github.com/Linaro/lite-cornea.git" target="_blank" rel="noopener"
>lite-cornea&lt;/a>&lt;/strong>
&lt;ul>
&lt;li>基于 Rust，可直接嵌入 GDB 终端，命令兼容性较好。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&lt;a class="link" href="https://github.com/santongding/iris-gdb-wrapper" target="_blank" rel="noopener"
>iris-gdb-wrapper&lt;/a>&lt;/strong>
&lt;ul>
&lt;li>基于 Python，需要先运行后端服务，然后以远程模式连接 GDB。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>经测试，lite-cornea 支持更多 GDB 命令（如 &lt;code>dump&lt;/code>、&lt;code>restore&lt;/code>），推荐使用。iris-gdb-wrapper 在使用这些命令时有一些 bug，不能正常导入导出内存。&lt;/p>
&lt;h2 id="安装-lite-cornea">安装 lite-cornea
&lt;/h2>&lt;h3 id="安装-rust-环境">安装 Rust 环境
&lt;/h3>&lt;p>运行以下命令快速安装：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">curl --proto &lt;span class="s1">&amp;#39;=https&amp;#39;&lt;/span> --tlsv1.2 -sSf https://sh.rustup.rs &lt;span class="p">|&lt;/span> sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装完成后，&lt;strong>重启终端&lt;/strong>并验证 Rust：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">cargo --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="编译并安装-lite-cornea">编译并安装 lite-cornea
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git clone https://github.com/Linaro/lite-cornea.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> lite-cornea
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cargo build
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo cp target/debug/cornea /usr/bin/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cornea --help
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="使用-gdb--lite-cornea-调试-fvp">使用 GDB + lite-cornea 调试 FVP
&lt;/h2>&lt;h3 id="配置-fvp-启动参数">配置 FVP 启动参数
&lt;/h3>&lt;p>在启动 FVP 时，添加 -I 参数以启用 Iris Debug Server。&lt;/p>
&lt;h3 id="编写-gdb-调试脚本">编写 GDB 调试脚本
&lt;/h3>&lt;p>创建一个 GDB 启动脚本（例如 debug.sh）并添加以下内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/usr/bin/env -S gdb -q -ix
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="nb">set&lt;/span> architecture aarch64
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">add-symbol-file /path/to/your/symbol/file
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">target remote &lt;span class="p">|&lt;/span> cornea gdb-proxy component.FVP_Base_RevC_2xAEMvA.cluster0.cpu0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="启动调试">启动调试
&lt;/h3>&lt;p>运行 FVP 后，执行调试脚本：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sh debug.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>脚本执行成功后，会自动进入 GDB 调试终端，默认停在 0x0 的位置，方便后续调试：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ ./gdb-connect-fvp2.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">The target architecture is &lt;span class="nb">set&lt;/span> to &lt;span class="s2">&amp;#34;aarch64&amp;#34;&lt;/span>.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">warning: No executable has been specified and target does not support
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">determining executable automatically. Try using the &lt;span class="s2">&amp;#34;file&amp;#34;&lt;/span> command.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x0000000000000000 in ?? &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>注意&lt;/strong>：&lt;/p>
&lt;p>cornea 参数中的 FVP_Base_RevC_2xAEMvA 需替换为实际运行的 FVP 模型名称，与 FVP 的二进制文件名（例如 FVP_Base_RevC-2xAEMvA）相似。
如果不确定模型名称，请参考 &lt;a class="link" href="https://documentation-service.arm.com/static/615eda5ce4f35d24846799a7" target="_blank" rel="noopener"
>ARM FVP 文档&lt;/a> 中的模型目录：&lt;/p>
&lt;p>&lt;img src="https://blog.zlaaa.top/post/debug-fvp-via-gdb/imgs/fvp-guide-catalog.png"
loading="lazy"
alt="ARM FVP Base Model目录"
>&lt;/p></description></item></channel></rss>