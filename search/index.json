[{"content":"前言 最近在为 Hypervisor 适配新平台 ARM Fixed Virtual Platforms (FVPs)，具体架构是 FVP + Hypervisor + Guest OS，发现 Guest OS 无法启动。然而，QEMU + Hypervisor + Guest OS 一切正常。进一步调试后发现，在 FVP 场景下，Guest OS 中所有未初始化的全局变量均不是零值，导致默认它们为零的代码出现错误。\n根据 C 标准，未初始化的全局变量应默认置零：\n如果一个具有自动存储周期的对象不被显式地初始化，那么其值是不确定的。如果具有静态或线程存储周期的一个对象不被显式初始化，那么\n—— 如果它具有指针类型，那么它被初始化为一个空指针；\n—— 如果它具有算术类型，那么它被初始化为（正的或负的）零；\n—— 如果它是一个聚合类型，那么每个成员被初始化（递归地），根据以上规则，并且任何填充被初始化为零比特；\n—— 如果它是一个联合体，那么第一个命名成员被（递归地）初始化，根据以上规则，并且填充被初始化为零比特。\n问题分析 对于 ELF 文件来说，存储变量的叫数据段。数据段分为 .data 段和 .bss 段，其中 .data 段存储已经初始化的全局变量和静态变量，.bss 段存储未经初始化的全局变量。\n.bss 段属于 nload 段，在镜像中不占空间，镜像被加载后，才会映射到内存，此时 .bss 段的内容继承自被映射的内存区域。\n很不幸，我运行的 Guest OS 并没有清零自己的 .bss 段，而且 Hypervisor 的实现也比较简单，仅仅是做了以下内存映射：GPA -\u0026gt; HVA -\u0026gt; HPA，将自身的 memory 区域一一映射给 Guest OS，也没有对这部分内存做置零处理。\n但是为什么 QEMU + Hypervisor + Guest OS 正常运行，而 FVP + Hypervisor + Guest OS 不行呢？\n这是因为 QEMU 提供的可用内存的默认值都是 0： 而 FVP 提供的可用内存区域默认值是 0xcfdfdfdf 与 0xdfdfdfcf 的循环： 具体见 FVP 的 params：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 FVP_Base_RevC-2xAEMvA --list-params | grep fill bp.dmc.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dmc.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dmc_phy.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dmc_phy.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_local_dap_rom.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_local_dap_rom.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_ram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_ram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_usb.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_usb.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.ns_dram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.ns_dram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.psram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.psram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.rl_dram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.rl_dram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.rt_dram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.rt_dram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.s_dram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.s_dram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.secureDRAM.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.secureDRAM.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.secureSRAM.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.secureSRAM.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.sram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.sram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.vram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.vram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern cluster0.ext_abort_fill_data=18302063723721653757 # (int , init-time) default = \u0026#39;0xfdfdfdfcfcfdfdfd\u0026#39; : Returned data, if external aborts are asynchronous cluster0.randomize_unknowns_at_reset=0 # (bool , init-time) default = \u0026#39;0\u0026#39; : Will fill in unknown bits in registers at reset with random value using register_reset_data as seed, it overrides scramble_unknowns_at_reset cluster0.register_reset_data=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill register bits when they become UNKNOWN at reset. cluster0.register_reset_data_hi=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill the upper-half of 128-bit registers when the bits become UNKNOWN at reset. cluster0.scramble_unknowns_at_reset=1 # (bool , init-time) default = \u0026#39;1\u0026#39; : Will fill in unknown bits in registers at reset with register_reset_data cluster0.unpred_extdbg_unknown_bits=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill only in UNKNOWN bit-fields of external debug registers e.g., EDPFR and EDDFR. cluster1.ext_abort_fill_data=18302063723721653757 # (int , init-time) default = \u0026#39;0xfdfdfdfcfcfdfdfd\u0026#39; : Returned data, if external aborts are asynchronous cluster1.randomize_unknowns_at_reset=0 # (bool , init-time) default = \u0026#39;0\u0026#39; : Will fill in unknown bits in registers at reset with random value using register_reset_data as seed, it overrides scramble_unknowns_at_reset cluster1.register_reset_data=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill register bits when they become UNKNOWN at reset. cluster1.register_reset_data_hi=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill the upper-half of 128-bit registers when the bits become UNKNOWN at reset. cluster1.scramble_unknowns_at_reset=1 # (bool , init-time) default = \u0026#39;1\u0026#39; : Will fill in unknown bits in registers at reset with register_reset_data cluster1.unpred_extdbg_unknown_bits=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill only in UNKNOWN bit-fields of external debug registers e.g., EDPFR and EDDFR. 以上配置项显示了 FVP 可以对如下内存区域进行配置：\nbp.dmc.* 和 bp.dmc_phy.*\n表示 DRAM Controller（内存控制器）及其物理层相关的内存填充值。\n用途：初始化内存控制器的地址空间，可能包括配置寄存器、缓冲区等。\nbp.ns_dram.*\n表示 Non-Secure DRAM（非安全动态随机存取存储器）的填充值。\n用途：初始化普通内存区域（非安全内存），模拟器启动时填充的默认模式。\nbp.rl_dram.* 和 bp.rt_dram.*\n表示 Real-time Left 和 Real-time Right DRAM，分别对应系统的左右两部分实时内存。\n用途：通常用于模拟分区的实时内存。\nbp.s_dram.* 和 bp.secureDRAM.*\n表示 Secure DRAM（安全动态随机存取存储器）的填充值。\n用途：存储安全相关数据，例如密钥、加密缓存等。\nbp.psram.*\n表示 PSRAM（伪静态随机存取存储器）的填充值。\n用途：嵌入式设备中用于提高性能的混合型存储器。\nbp.sram.* 和 bp.secureSRAM.*\n表示 SRAM（静态随机存取存储器）和 Secure SRAM 的填充值。\n用途：SRAM 通常用于高速缓存或快速存储，Secure SRAM 用于安全用途。\nbp.vram.*\n表示 VRAM（视频随机存取存储器）的填充值。\n用途：用于存储图形数据或显示缓冲区。\nbp.dummy_*\n表示模拟器中用于占位或辅助调试的虚拟内存区域（如 dummy_ram、dummy_usb）。\n用途：不对应真实硬件，而是提供测试或开发的功能。\n关于 fill1 和 fill2，如果他们的值分别是 A 和 B，那么 FVP 的对应内存区间的值就会是 ABABABABABABABABABAB\u0026hellip;\u0026hellip; 的循环。\n如果不对 FVP 内存初始值进行配置，.bss 段“展开”后的内容就是默认的 0xcfdfdfdfdfdfdfcf，这也是为什么 debug 过程中看到所有未经初始化的值都是 0xcfdfdfdfdfdfdfcf。\n对于我这个例子，Guest OS 镜像是嵌入 Hypervisor 镜像中的，经过测试，发现 Hypervisor 镜像所在内存区间为 bp.s_dram，为 FVP 添加如下启动参数后，Guest OS 可以正常启动：\n1 2 -C bp.s_dram.fill1=0x0 \\ -C bp.s_dram.fill2=0x0 PS:\n关于为什么是 bp.s_dram，FVP 手册中可以找到一些蛛丝马迹。其实我是挨个试的\nHypervisor 镜像所在内存区间的安全属性是 P 对于P，默认的处理策略是安全访问和非安全访问全部拒绝，我猜测拒绝非安全访问的区间，都在 bp.s_dram 的配置范围内。但是我也查看了一些N/S区间，并不是所有的N/S区间都在 bs.s_dram 的配置范围内。如果有知道的同学可以在评论区⬇️讨论下。 ","date":"2025-01-06T21:01:07+08:00","permalink":"https://blog.zlaaa.top/p/global-val-is-not-zero-in-fvp/","title":"ARM Fixed Virtual Platforms (FVPs)中运行 Hypervisor，Guest OS 的全局变量没有置零"},{"content":"前言 最近在 Debug U-boot 的过程中遇到了无法打断点的问题，找了好久才确定是 U-Boot 自身做 relocate 造成的，其实这个问题在 U-Boot 官方文档中有提及，所以这里做一下记录。\n减少编译优化与禁用链接时间优化 为了方便调试，防止有些变量被优化掉导致 gdb 中看不到，在 U-Boot 的 defconfig 中添加如下配置\n1 2 CONFIG_CC_OPTIMIZE_FOR_DEBUG=y CONFIG_LTO=n 开启 U-Boot Debug 日志输出 修改 u-boot/include/log.h\nU-Boot relocate 介绍 U-Boot在启动阶段会将自己的地址做重定向，一开始 add-symbol-file 时没有加地址也可以正常使用，是因为在没有 relocate 前，U-Boot 的地址与符号表中的一致。执行 relocate (u-boot/arch/arm/lib/relocate_64.S) 操作后，U-Boot 的运行地址发生变化，原来导入的符号表就不能用了，需要将符号表导入到新的地址。\nU-Boot Debug 过程 第一步：添加符号表（无需指定地址） 1 add-symbol-file ./workdir/src/u-boot/u-boot 第二步：在 relocate_done 函数处打断点并运行 u-boot 1 2 3 4 5 6 7 (gdb) break relocate_done Breakpoint 1 at 0x88002e8c: file arch/arm/lib/relocate_64.S, line 80. (gdb) c Continuing. Breakpoint 1, relocate_code () at arch/arm/lib/relocate_64.S:80 80 switch_el x1, 3f, 2f, 1f 第三步：查看 U-Boot 重定向后的运行地址 1 2 (gdb) p/x (*(struct global_data*)$x18)-\u0026gt;relocaddr $2 = 0xfef1e000 注意：\n这一步中，具体的寄存器见表，我这里是 arm64 架构的，所以结构体地址存储在 x18 寄存器中：\nArchitecture Register arc r25 arm r9 arm64 x18 m68k d7 microblaze r31 mips k0 nios2 gp powerpc r2 riscv gp sh r13 第四步：删除原先符号表 1 2 3 (gdb) symbol-file Discard symbol table? (y or n) y No symbol file now. 第五步：将符号表加载到重定向后的地址 1 2 3 4 5 (gdb) add-symbol-file ./workdir/src/u-boot/u-boot 0xfef1e000 add symbol table from file \u0026#34;./workdir/src/u-boot/u-boot\u0026#34; at .text_addr = 0xfef1e000 (y or n) y Reading symbols from ./workdir/src/u-boot/u-boot... 注意：\n是否重新导入符号表取决于打断点的位置，如果在 relocate 操作前则不需要，反之则需要。\n","date":"2025-01-05T19:03:20+08:00","permalink":"https://blog.zlaaa.top/p/debug-u-boot/","title":"如何 Debug U-Boot"},{"content":"概述 在调试 ARM FVP 模型时，直接通过 GDB 连接是行不通的。虽然 ARM 官方为付费版 Fast Model 提供了 GDB 插件，但免费版 Base Model 并不支持该功能。取而代之，Base Model 提供了一种名为 Iris Debug Server 的 Python Debug API。因此，要使用 GDB 调试 Base FVP，需要通过中间工具进行协议转译。\n本文将介绍如何使用 lite-cornea 工具简化 FVP 的调试过程。\n调试工具选择 目前找到的 Iris-to-GDB 转译工具有以下两个：\nlite-cornea 基于 Rust，可直接嵌入 GDB 终端，命令兼容性较好。 iris-gdb-wrapper 基于 Python，需要先运行后端服务，然后以远程模式连接 GDB。 经测试，lite-cornea 支持更多 GDB 命令（如 dump、restore），推荐使用。iris-gdb-wrapper 在使用这些命令时有一些 bug，不能正常导入导出内存。\n安装 lite-cornea 安装 Rust 环境 运行以下命令快速安装：\n1 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装完成后，重启终端并验证 Rust：\n1 cargo --version 编译并安装 lite-cornea 1 2 3 4 5 git clone https://github.com/Linaro/lite-cornea.git cd lite-cornea cargo build sudo cp target/debug/cornea /usr/bin/ cornea --help 使用 GDB + lite-cornea 调试 FVP 配置 FVP 启动参数 在启动 FVP 时，添加 -I 参数以启用 Iris Debug Server。\n编写 GDB 调试脚本 创建一个 GDB 启动脚本（例如 debug.sh）并添加以下内容：\n1 2 3 4 #!/usr/bin/env -S gdb -q -ix set architecture aarch64 add-symbol-file /path/to/your/symbol/file target remote | cornea gdb-proxy component.FVP_Base_RevC_2xAEMvA.cluster0.cpu0 启动调试 运行 FVP 后，执行调试脚本：\n1 sh debug.sh 脚本执行成功后，会自动进入 GDB 调试终端，默认停在 0x0 的位置，方便后续调试：\n1 2 3 4 5 6 7 $ ./gdb-connect-fvp2.sh The target architecture is set to \u0026#34;aarch64\u0026#34;. warning: No executable has been specified and target does not support determining executable automatically. Try using the \u0026#34;file\u0026#34; command. 0x0000000000000000 in ?? () (gdb) 注意：\ncornea 参数中的 FVP_Base_RevC_2xAEMvA 需替换为实际运行的 FVP 模型名称，与 FVP 的二进制文件名（例如 FVP_Base_RevC-2xAEMvA）相似。 如果不确定模型名称，请参考 ARM FVP 文档 中的模型目录：\n","date":"2025-01-05T15:59:16+08:00","permalink":"https://blog.zlaaa.top/p/debug-fvp-via-gdb/","title":"使用 lite-cornea 调试 ARM Fixed Virtual Platforms (FVPs)"},{"content":"在使用 VS Code 打开包含大量文件的 C/C++ 项目时，经常会遇到 CPU 占用过高的问题。尤其是当同时打开多个 VS Code 窗口时，CPU 占用会成倍增加，有时甚至高达 400%，几乎完全占满 4 个核心。经排查，这是由于 C/C++ 插件在分析代码，而我的项目中包含 Linux 源码、u-boot 源码、buildroot 源码等大型代码库，导致插件一直在进行代码分析，进而引发系统卡顿。\n解决方法：排除目录 可以通过修改 settings.json 文件，为 C/C++ 插件排除特定目录。以下是我的配置示例：\n1 2 3 4 5 6 7 8 \u0026#34;C_Cpp.files.exclude\u0026#34;: { \u0026#34;**/.git\u0026#34;: true, \u0026#34;**/workdir\u0026#34;: true, \u0026#34;**/wkdir\u0026#34;: true, \u0026#34;**/build\u0026#34;: true, \u0026#34;**/bin\u0026#34;: true, \u0026#34;/PROJECT_ROOT/COMPONENT/ANONYMIZED\u0026#34;: true, } 值得注意的是，配置的是C_Cpp.files.exclude而非files.exclude，如果配置成后者，这些目录会被 VS Code 的文件资源管理器排除，跟消失了一样。 配置说明 **/workdir 和 **/wkdir：我的项目中，大量外部源码存储在这两个目录中。\n/PROJECT_ROOT/COMPONENT/ANONYMIZED：该目录是 C/C++ 插件缓存代码分析结果的存储位置，排除它可以防止插件重复递归分析自身的缓存文件而产生死循环。\n参考 有关插件缓存目录（/PROJECT_ROOT/COMPONENT/ANONYMIZED）的更多讨论，可以参考 GitHub Issue。\n","date":"2024-12-04T18:27:07+08:00","permalink":"https://blog.zlaaa.top/p/fix-vscode-cpptools-cpu-usage-too-high/","title":"VS Code C/C++ 插件 cpptools CPU 占用过高"},{"content":"Linenoise 简介 Linenoise 是一个轻量级的行编辑库，适用于需要简单命令行编辑功能的应用程序，可以用它快速完成 shell 的开发。它支持多平台，并且与 GNU Readline 库相比，Linenoise 的代码更加简洁，易于集成和使用。\n转义序列显示异常 在移植 Linenoise 之后，发现此时 Shell 存在一个 Bug，长按某些按键时会输出[D、[A、D、A之类的乱码，例如，长按左右方向键时会输出如下字符，并且出现的时机不规律。\n分析 按理来说按下左右方向键不应输出任何字符，所以肯定和左右方向键的转义序列有关，一些按键的转义序列如下：\n上箭头键：ESC [ A 或 \\x1b[A 下箭头键：ESC [ B 或 \\x1b[B 左箭头键：ESC [ D 或 \\x1b[D 右箭头键：ESC [ C 或 \\x1b[C 删除键（Del）：ESC [ 3 ~ 或 \\x1b[3~ 查看 Linenoise 源码发现，处理逻辑为逐个尝试输入ESC、[、A/B/C/D/数字～\n问题就出在逐个输入这里，如果输入采用的串口不稳定（我这里是 pl011），快速输入就会导致读取失败（Linenoise 读取时串口缓冲区还没有数据），这里直接 break 就会导致状态机跳出当前状态，使得ESC、[、A三者被拆开，并没有当作一个上箭头键来处理。\n解决方案 解决方案也很简单，就是将 break 改成循环读入，如果读取失败就重新尝试。\n1 2 3 4 5 while (1) { if (read(l-\u0026gt;ifd, seq, 1) != -1) { break; } } ","date":"2024-11-07T17:10:33+08:00","permalink":"https://blog.zlaaa.top/p/bug-while-inputing-escape-sequences-in-linenoise/","title":"使用Linenoise时转义序列显示异常"},{"content":"在使用 VMware Fusion 时，可能会遇到 Ubuntu 虚拟机磁盘空间不足的问题。本文将介绍如何在 VMware Fusion 中扩展 Ubuntu 虚拟机的磁盘容量，以确保系统能够正常运行并满足更多存储需求。\n在 VMware Fusion 中增加 Ubuntu 的硬盘分配空间 首先将 Ubuntu 虚拟机关机，然后在 VMware Fusion 中配置硬盘空间。\n在 Ubuntu 中分配新增空间 此时新增的空间只是未分配空间，并没有真正用于 Ubuntu，磁盘大小并没有改变。\n可以使用 GParted 图形化分区编辑工具对硬盘进行分配。\n如图所示，新增的 130G 空间尚未分配。\n首先点击原有的磁盘空间，再点击 resize 按钮，将其扩大至最大。\n完成后可以看到根目录磁盘空间已经扩大至 150G。\n","date":"2024-10-19T16:18:16+08:00","permalink":"https://blog.zlaaa.top/p/expand-ubuntu-disk-capacity/","title":"在 VMware Fusion 中扩展 Ubuntu 虚拟机磁盘容量"},{"content":"Hugo 是一个用 Go 语言编写的静态网站生成器，以速度快、易用性高和灵活性强而著称。Hugo 通过结合 Markdown 文件和模板，能够快速生成静态网页，适用于博客、文档和个人网站等场景。它支持多种主题和插件，能够轻松部署到 GitHub Pages 等平台，非常适合开发者和内容创作者使用。\nHugo 提供了许多主题，我使用的是 Hugo Stack。在部署过程中，如果使用 Hugo 官方文档，即使已经取消 draft 标记，也无法显示新建的文章：Issue。可以直接使用 Hugo Stack 的官方模板 来解决这个问题。\n使用模板创建仓库 创建的仓库名为username.github.io，username为自己的github用户名。\n将仓库克隆到本地并安装 Hugo 拓展版 Linux 1 sudo apt install hugo Mac OS 1 brew install hugo Windows 1 choco install hugo-extended 或者直接下载二进制\n新增文章并发布 1 hugo new content content/posts/my-first-post.md 使用此命令创建的文章有 draft 标记，Hugo 在默认情况下并不会发布带有此标记的文章，需要添加 -D 或 --buildDrafts 参数。\n确认发布后，将 draft 标记改为 false，提交 commit 至 GitHub 即可。\nGitHub Actions 自动化发布 Hugo Stack 模板仓库内包含 deploy.yml、update-theme.yml 两个 GitHub Workflow 文件，分别负责自动化发布和更新主题版本，详见 Hugo Stack GitHub Workflows。仓库的更新会触发 GitHub Actions 进行自动化发布。\nGitHub Pages 配置 deploy.yml 会将博客发布到 gh-pages 分支。\n所以需要在仓库设置中更改 Pages 的分支为 gh-pages。\n如果没有 gh-pages 选项，可能 GitHub Actions 还在构建中，等待构建完毕即可。\n自定义域名 发布完毕后，可以通过 https://username.github.io 访问，也可以配置自定义域名。\n只需要将你的域名 CNAME 指向 username.github.io，并在仓库设置中添加 Custom domain，等待 DNS 验证成功后，即可使用自定义的域名访问刚刚发布的博客。\n同时也可以配置强制 https 以增强安全性。\n添加 Giscus 评论系统 Hugo支持多种评论系统，我选择了 Giscus。Giscus 会将所有的评论保存至Github Discussion，无需担心数据丢失的问题。\n安装 Giscus App 至当前仓库 Giscus App\n开启仓库的 Discussion 功能 在 Giscus 官网获取配置信息 在 Hugo 配置文件中启用 Giscus 评论系统 配置信息与上一步在 Giscus 官网获取的信息相对应，配置文件示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 # config/_defconfig/params.toml [comments.giscus] repo = \u0026#34;zlaazlaa/zlaazlaa.github.io\u0026#34; repoId = \u0026#34;R_kgDONAZhPA\u0026#34; category = \u0026#34;Announcements\u0026#34; categoryId = \u0026#34;DIC_kwDONAZhPM4CjXiy\u0026#34; mapping = \u0026#34;pathname\u0026#34; lightTheme = \u0026#34;\u0026#34; darkTheme = \u0026#34;\u0026#34; reactionsEnabled = 1 emitMetadata = 0 ","date":"2024-10-17T13:39:46+08:00","permalink":"https://blog.zlaaa.top/p/how-to-use-hugo/","title":"使用 Hugo Stack 和 GitHub Pages/Actions 搭建博客"},{"content":"欢迎来到我的博客！在这里，我将分享我的编程经验、技术心得以及生活中的点滴。希望你能在这里找到有用的信息，并与我一起成长。感谢你的访问，祝你阅读愉快！\n","date":"2024-10-15T17:06:46+08:00","permalink":"https://blog.zlaaa.top/p/welcome-to-my-blog/","title":"欢迎来到我的博客"}]